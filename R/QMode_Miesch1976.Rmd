---
title: "Q-Mode Miesch 1976"
author: "Dr. Nils Blum-Oeste"
date: "12/28/2016"
bibliography: pva.bib
output:
  html_document:
    toc: true
    toc_float: true
    collapsed: false
    df_print: kable
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
```


# Introduction

This notebook serves as a reference implementation of the Q-Mode analysis in R as described by @miesch_q-mode_1976.

# Definition of original example data

```{r}
original_data = tibble (
  x1 = c(90,50,80,60,85,95),
  x2 = c(7, 10, 15, 30, 10, 3),
  x3 = c(3, 40, 5, 10, 5, 2)
)

original_data
```


# Transformation and Normalization
## Range-Transformation

Get $xmin$ and $xmax$ values:

```{r}
mins_maxs <- function (data) {
  tibble(
    variable = colnames(original_data),
    min = sapply(original_data, min),
    max = sapply(original_data, max)
  )
}
mins_maxs(original_data)
```

Transform the data to proportions of the range of each variable:

$x'_{ij}=(x_{ij}-xmin_j)/(xmax_j-xmin_j)$

```{r}
range_transformed <- function(data) {
  minmax <- mins_maxs(original_data)
  mins <- minmax$min
  maxs <- minmax$max
  t((t(data) - mins) / (maxs - mins)) %>%
    as_tibble()
}
range_transformed(original_data)
```

The range transformed data is identical to the data in @miesch_q-mode_1976 [, Table 1C].

## Normalization factors $t_i$

The normalization suggested byt @miesch_q-mode_1976 results in rows where the sum of squares equals 1 (in contrast to @klovan_algorithm_1971 where the simple sum equals 1).

$t_i = \sqrt{\displaystyle\sum_{j}{x'^{2}_{ij}}}$

```{r}
normalization_factors <- function(data) {
  data %>%
    range_transformed() %>%
    transmute(ti = Reduce(function(u, v){u+v**2}, ., 0)**0.5) %>%
    as_vector()
}

normalization_factors(original_data)
```

The normalization factors are equal to those from @miesch_q-mode_1976 [, Table 1C].

## Normalized and transformed data


```{r}
normalize_and_transform <- function(data) {
  as.matrix(range_transformed(data) / 
    normalization_factors(data))
}

normalize_and_transform(original_data)
```

These values also match the ones by @miesch_q-mode_1976 [, Table 1C].

The sum of squares per row should equal 1:

```{r}
normalize_and_transform(original_data)**2 %>%
  rowSums()
```


# Q-Mode Factor Analysis

## Initial loadings $a_{ij}$:

```{r}
initial_loadings <- function(data) {
  pca <- data %>%
    normalize_and_transform() %>%
    prcomp(center = F, scale = F)
  pca$x
}
initial_loadings(original_data) %>% as_tibble()
```

The values equal those in @miesch_q-mode_1976 [, Table 4].

## Unscaled factor scores $f''_{kj}$

The following part of the Q-Mode analysis is done as described in @klovan_algorithm_1971.

### Row normalization

Calculate a diagonal matrix with the row-sum of squares:

```{r}
rowsum_square_diag <- function(data) {
  data %>%
    rowSums() %>%
    (function(x){x**2}) %>%
    diag()
}

original_data %>%
  rowsum_square_diag()
```

Calculate row-normalized data matrix $W = D^{-1/2}X$:

```{r}
row_normalized_data <- function(data) {
  D <- rowsum_square_diag(data)
  D_ <- D
  diag(D_) <- diag(D_)**-0.5
  X <- as.matrix(data)
  D_ %*% X
}

row_normalized_data(range_transformed( original_data))
```

The simple row sums should be 1:

```{r}
original_data %>%
  row_normalized_data() %>%
  rowSums()
```

### Normal Q-Mode

Cosine-theta matrix $S = WW'$:

```{r}
cosine_theta <- function(data) {
  W <- row_normalized_data(data)
  W %*% t(W)
}

cosine_theta(original_data)
```

Eigenvalues of the cosine-theta matrix $S$:

```{r}
eigen(cosine_theta(original_data))$values
```

Calculate the principal factor-loadings matrix $Q=U\Lambda^{-0.5}$:

```{r}
principal_factor_loadings <- function(data) {
  S   <- cosine_theta(data)
  eig <- eigen(S)
  U   <- eig$vectors[,1:3]
  A_  <- diag(eig$values[1:3]**-0.5)
  U %*% A_
}

principal_factor_loadings(original_data)
```

Calculate the principal factor-score matrix $F_p=W'Q\Lambda^{-1}$:

```{r}
principal_factor_score <- function(data) {
  W_ <- t(row_normalized_data(data))
  Q  <- principal_factor_loadings(data)
  S  <- cosine_theta(data)
  x  <- svd(S)$d[1:3]**-1
  A_ <- diag(x)
  W_ %*% Q %*% A_
}

t(principal_factor_score(normalize_and_transform( original_data)))
```

These do not match with the values in Miesch at all.

### CABFAC algorithm

This algorithm was introduced to reduce the computational complexity of the task. It operates on fewer dimensions.

$P = W'W$

$Q = W \mathring{U}$

```{r}
cabfac_P <- function(data) {
  W <- normalize_and_transform(data) 
  t(W) %*% W
}

cabfac_Q <- function(data) {
  W <- normalize_and_transform(data) 
  P <- cabfac_P(data)
  U_circ <- svd(P)$u
  W %*% U_circ
}

cabfac_Q(original_data)
cabfac_P(original_data)
```

Unscaled scores $F_p$:

```{r}
unscaled_scores <- function(data) {
  P <- cabfac_P(data)
  svd(P)$u %>%
    t()
}

unscaled_scores(original_data)
```

Alternatively calculate it from `cabfac_Q`:

```{r}
t(row_normalized_data(original_data)) %*%
  cabfac_Q(original_data) %*%
  diag(svd(cosine_theta(original_data))$d**-1)[1:3,1:3]
```

Same result as above, but still not matching the values from @miesch_q-mode_1976 [, Table 4]


# Validate results

Comparison of eigenvalues (non-zero eigenvalues should be identical):

```{r}
svd(cabfac_P(original_data))$d

svd(cosine_theta(original_data))$d
```

The product of $a''_{ik}$ and $f''_{kj}$ should equal the normalized, transformed data.

Calculated data:

```{r}
cabfac_Q(original_data) %*% unscaled_scores(original_data) %>% as_tibble()
```

Original data:

```{r}
normalize_and_transform(original_data) %>% as_tibble()
```


# References